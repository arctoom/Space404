<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space404</title>
    <link rel="icon" href="logo.png" type="image/png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000;
            overflow: hidden;
            /* --- Швейцарский панк: Сильный Sans-Serif, высокий контраст --- */
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; 
            color: #E0E0E0; /* Слегка смягченный белый */
            font-weight: 500; /* Немного жирнее */
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* --- Помещаем canvas ПОД все остальное --- */
            opacity: 0.6; /* --- Делаем сферу менее навязчивой --- */
        }

        #error-message {
            color: red;
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 100;
            font-size: 0.8em;
            background: rgba(0,0,0,0.7);
            padding: 5px;
        }

        #logo {
            position: fixed;
            /* --- Перемещаем лого в левый верхний угол --- */
            top: 30px;
            left: 30px;
            /* right: 20px; */
            height: 50px; /* Можно настроить размер */
            width: auto;
            z-index: 10;
        }

        /* --- Стили для плеера --- */
        #music-player {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* --- Возвращаем фон и отступы --- */
            background-color: rgba(10, 10, 10, 0.8); /* Очень темный, полупрозрачный */
            backdrop-filter: blur(8px); /* Усилим размытие фона */
            border: 1px solid rgba(255, 255, 255, 0.08); /* Едва заметная граница */
            padding: 20px 25px; /* Добавляем отступы */
            border-radius: 4px; /* Слегка скруглим углы */
            width: 420px; /* Еще немного шире для новых кнопок */
            font-family: inherit;
            z-index: 20; 
            color: inherit;
            text-align: center;
        }

        #player-controls {
             /* --- Используем Flexbox для кнопок --- */
            display: flex;
            justify-content: center; /* Центрируем кнопки */
            align-items: center;
            margin-bottom: 15px; /* Отступ снизу */
        }

        #player-controls button,
        #add-track-button {
            background: none;
            border: none; 
            color: #E0E0E0; 
            padding: 8px 10px; /* Немного скорректируем */
            margin: 0 10px; /* Увеличим отступ между кнопками */
            cursor: pointer;
            border-radius: 0px; 
            transition: color 0.2s;
            font-size: 1.1em; 
            font-weight: 700; 
            min-width: 40px; /* Минимальная ширина для иконок/текста */
            text-align: center;
        }
        #add-track-button {
             margin-top: 15px; /* Отступ сверху для кнопки Add */
        }
        #player-controls button:hover,
        #add-track-button:hover {
            color: #ffffff; 
        }
        #player-controls button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            color: #777;
        }
        /* Стиль для активных кнопок shuffle/loop */
        #player-controls button.active {
            color: #4CAF50 !important; /* !!! Используем !important для уверенности !!! */
            font-weight: bold !important; 
        }

        #track-info {
            margin-bottom: 15px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 1.1em; /* Чуть меньше */
            min-height: 1.3em; 
            font-weight: 700; 
            color: #ffffff; 
        }

        #progress-container,
        #volume-container {
            width: 100%;
            height: 5px; /* Немного толще */
            background-color: #333; /* Чуть светлее фон */
            border-radius: 0px;
            cursor: pointer;
            margin: 12px 0; /* Увеличим вертикальные отступы */
            position: relative;
        }
        #volume-container {
             width: 120px; 
             margin: 15px auto; /* Отступы для громкости */
             display: block; /* Убедимся, что он виден */
        }

        #progress-bar,
        #volume-bar {
            height: 100%;
            background-color: #E0E0E0; 
            border-radius: 0px;
            width: 0; 
        }
        #volume-bar { width: 30%; } /* Начальная громкость (визуальная) */

        #time-display {
            font-size: 0.8em; /* Мельче время */
            color: #777; 
            text-align: center;
            margin-top: 8px;
            margin-bottom: 15px;
        }

        /* --- Стили для контейнера и списка плейлиста --- */
        #playlist-container {
            max-height: 0; 
            opacity: 0;
            overflow-y: auto;   /* !!! ВОЗВРАЩАЕМ ПРОКРУТКУ СЮДА !!! */
            transition: max-height 0.4s ease-out, opacity 0.3s ease-in, margin-top 0.4s ease-out, padding-top 0.4s ease-out;
            margin-top: 0;
            padding-top: 0;
            border-top: none; 
            /* ВОЗВРАЩАЕМ правила скрытия скроллбара */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE/Edge */
        }
        /* ВОЗВРАЩАЕМ правило скрытия скроллбара WebKit */
        #playlist-container::-webkit-scrollbar {
            display: none; 
        }

        #playlist-container.playlist-visible {
            max-height: 100px; 
            opacity: 1;
            margin-top: 15px; 
            padding-top: 10px;
            border-top: 1px solid #333; 
        }

        #playlist {
            list-style: none;
            padding: 0;
            /* padding-right: 20px; */ /* Убираем отступ */
            /* overflow-y: scroll; */ /* Возвращаем как было */
            /* height: 100%; */       /* Убираем высоту */
            font-size: 0.9em; 
            text-align: center;
        }
        #playlist li {
            padding: 5px 8px;
            cursor: pointer;
            border-bottom: none; 
            transition: color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #888; /* Еще темнее неактивные */
            font-weight: 400; /* Устанавливаем нормальный вес для неактивных */
        }

        #playlist li:hover {
           color: #E0E0E0;
        }
        #playlist li.playing {
            color: #fff;
            font-weight: 700; /* Убеждаемся, что жирный шрифт установлен */
        }
        /* --- Конец стилей плейлиста --- */

        /* --- Стили для кнопки переключения плейлиста --- */
        #playlist-toggle-button {
            position: absolute; /* Позиционируем относительно плеера */
            bottom: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #888; /* Цвет стрелки */
            transition: transform 0.3s ease-out, color 0.2s;
        }

        #playlist-toggle-button::before {
            content: '';
            display: block;
            width: 8px;
            height: 8px;
            border-left: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transform: rotate(-45deg); /* Стрелка вниз */
            margin: auto;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0; 
        }

        #playlist-toggle-button:hover {
            color: #ccc;
        }

        /* Поворот стрелки, когда плейлист виден */
        #playlist-container.playlist-visible + #playlist-toggle-button {
             transform: rotate(180deg);
        }
        /* ------------------------------------------------ */

        /* Скрываем стандартный input file */
        #add-track-input {
            display: none;
        }
        /* -------------------------- */

    </style>
</head>
<body>
    <div id="error-message"></div>

    <!-- Логотип (перемещен CSS) -->
    <img id="logo" src="logo.png" alt="Logo">

    <!-- HTML Структура плеера (перемещен CSS) -->
    <div id="music-player">
        <div id="track-info">No track loaded</div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
        <div id="time-display">0:00 / 0:00</div>
        <div id="player-controls">
            <button id="shuffle-button" title="Shuffle">SHUF</button>
            <button id="prev-button" disabled title="Previous">&lt;&lt;</button>
            <button id="play-pause-button" disabled title="Play/Pause">Play</button>
            <button id="next-button" disabled title="Next">&gt;&gt;</button>
            <button id="loop-button" title="Loop Track">LOOP</button>
        </div>
        <div id="volume-container">
            <div id="volume-bar"></div>
        </div>
         <button id="add-track-button">Add Tracks</button>
        <input type="file" id="add-track-input" multiple accept="audio/*">
        <!-- Оборачиваем плейлист в контейнер -->
        <div id="playlist-container">
            <ul id="playlist">
                <!-- Элементы плейлиста -->
            </ul>
        </div>
        <!-- Кнопка для переключения видимости плейлиста -->
        <button id="playlist-toggle-button" title="Toggle Playlist"></button>
    </div>
    <!-- Конец структуры плеера -->

    <!-- Используем МОДУЛЬНУЮ версию Three.js -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script> -->
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // --- Импорты --- 
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        // --- Новые импорты для толстых линий ---
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        // ---------------------------------------

        try {
            // Проверка на THREE теперь не нужна так как импорт обязателен

            // --- Основные настройки сцены --- 
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            camera.position.z = 10; // Вернули камеру ближе

            // --- Пост-обработка: Настройка EffectComposer и Bloom --- 
            const renderScene = new RenderPass( scene, camera );
            const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.0, 0.5, 0.85 ); 
            // --- Параметры Bloom - Вернем к менее агрессивным, будем настраивать позже ---
            bloomPass.threshold = 0.85; // Повышаем порог, чтобы менее яркие части не светились
            bloomPass.strength = 0.5;  // Уменьшаем общую силу свечения
            bloomPass.radius = 0.5;    // Радиус пока оставим
            // -----------------------------------------------------------

            const composer = new EffectComposer( renderer );
            composer.addPass( renderScene );
            composer.addPass( bloomPass );
            // -----------------------------------------------------------

            // --- Материалы и параметры объекта ---
            // Убираем старый LineBasicMaterial
            /*
            const lineMaterial_old = new THREE.LineBasicMaterial({ 
                color: 0xffffff, // Тест: делаем линии ярко-белыми
                transparent: false, // Тест: убираем прозрачность
                opacity: 1.0 // Тест: полная непрозрачность
            });
            */
            // --- Новый LineMaterial для толстых линий ---
            const lineMaterial = new LineMaterial({ 
                color: 0x888888,       // Делаем цвет линий еще темнее
                linewidth: 2.5,         // Задаем толщину линии в пикселях
                transparent: true,     // Включаем прозрачность
                opacity: 0.5,          // Возвращаем полупрозрачность
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) // Устанавливаем разрешение
                // dashed: false, // Можно делать пунктирные линии, если нужно
                // alphaToCoverage: true, // Может улучшить сглаживание на некоторых системах
            });
            // -------------------------------------------

            // --- Создание ОДНОГО объекта: Сферы (с новыми линиями) --- 
            const sphereLinesGroup = new THREE.Group();
            const sphereRadius = 5.7; 
            const parallels = 30; 
            const meridians = 60; 

            // --- Создание параллелей с LineGeometry и Line2 ---
            for (let j = 1; j < parallels; j++) {
                const lat = Math.PI * (-0.5 + j / parallels);
                const r = sphereRadius * Math.cos(lat);
                const y = sphereRadius * Math.sin(lat);
                const points = []; 
                const segments = 64;
                for (let i = 0; i <= segments; i++) { 
                    const theta = (i / segments) * Math.PI * 2; 
                    points.push(Math.cos(theta) * r, y, Math.sin(theta) * r); // Собираем x, y, z подряд
                }
                const geometry = new LineGeometry();
                geometry.setPositions(points);
                const line = new Line2(geometry, lineMaterial);
                line.computeLineDistances(); // Важно для LineMaterial
                sphereLinesGroup.add(line);
            }
            // ----------------------------------------------------

            // --- Создание меридианов с LineGeometry и Line2 ---
            const pointsSphere = []; 
            const segmentsSphere = 64;
            for (let i = 0; i <= segmentsSphere; i++) { 
                const theta = (i / segmentsSphere) * Math.PI * 2; 
                // Создаем точки для одного меридиана (окружность в плоскости XY)
                pointsSphere.push(Math.cos(theta) * sphereRadius, Math.sin(theta) * sphereRadius, 0); 
            }
            const meridianGeometry = new LineGeometry();
            meridianGeometry.setPositions(pointsSphere);

            for (let i = 0; i < meridians; i++) { 
                const meridian = new Line2(meridianGeometry, lineMaterial);
                meridian.computeLineDistances(); // Важно для LineMaterial
                meridian.rotation.y = (Math.PI * 2 * i) / meridians;
                sphereLinesGroup.add(meridian); 
            }
            // ----------------------------------------------------
            
            // --- Внутренняя "туманная" сфера (остается как есть) ---
            const innerFogGeometry = new THREE.SphereGeometry(sphereRadius * 0.98, 32, 32); 
            const innerFogMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,      
                transparent: true,
                opacity: 0.95, // Высокая непрозрачность для скрытия задних линий
                depthWrite: false,    
                blending: THREE.NormalBlending
            });
            const innerFogSphere = new THREE.Mesh(innerFogGeometry, innerFogMaterial);
            sphereLinesGroup.add(innerFogSphere); 
            // ------------------------------------------

            scene.add(sphereLinesGroup); 

            // --- Освещение --- 
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1.0);
            pointLight.position.set(0, 10, 15); 
            scene.add(pointLight);

            // --- Переменные для взаимодействия --- 
            let mouseX = 0;
            let isDragging = false;
            let rotationDirection = 1; 
            const constantSpeed = 0.0015;
            let startX = 0;
            let startRotationY = 0;
            const dragSensitivity = 0.002; 
            let targetScale = 1.0;
            let currentScale = 1.0;
            const scaleFactorOnInteract = 1.05; 
            const scaleInterpolationFactor = 0.05;
            // Переменные для инерции и смешивания
            let previousDragRotationY = 0; 
            let currentRotationSpeed = constantSpeed * rotationDirection; // Текущая скорость (начинаем с постоянной)
            const inertiaFactor = 0.05; // Коэффициент для плавного перехода/затухания

            // --- Обработчики событий --- 
            function updateMouseX(clientX) {
                mouseX = (clientX / window.innerWidth) * 2 - 1;
            }

            // --- Добавляем ссылку на элемент плеера для проверки --- 
            const musicPlayerElement = document.getElementById('music-player');
            // -----------------------------------------------------

            document.addEventListener('mousemove', (event) => {
                updateMouseX(event.clientX); 
                if (isDragging) { 
                    const currentX = event.clientX;
                    const deltaX = currentX - startX;
                    const targetRotationY = startRotationY + deltaX * dragSensitivity;
                    // Запоминаем угол ПЕРЕД изменением
                    previousDragRotationY = sphereLinesGroup.rotation.y;
                    sphereLinesGroup.rotation.y = targetRotationY;
                }
            });

            document.addEventListener('touchmove', (event) => {
                updateMouseX(event.touches[0].clientX); 
                if (isDragging) { 
                    event.preventDefault();
                    const currentX = event.touches[0].clientX;
                    const deltaX = currentX - startX;
                    const targetRotationY = startRotationY + deltaX * dragSensitivity;
                    // Запоминаем угол ПЕРЕД изменением
                    previousDragRotationY = sphereLinesGroup.rotation.y;
                    sphereLinesGroup.rotation.y = targetRotationY;
                }
            }, { passive: false });

            document.addEventListener('mousedown', (event) => {
                // --- Проверка: игнорируем клики внутри плеера --- 
                if (musicPlayerElement && musicPlayerElement.contains(event.target)) {
                    return; 
                }
                // ---------------------------------------------
                isDragging = true;
                startX = event.clientX;
                startRotationY = sphereLinesGroup.rotation.y; 
                updateMouseX(event.clientX);
                targetScale = scaleFactorOnInteract; 
                currentRotationSpeed = 0; 
                previousDragRotationY = sphereLinesGroup.rotation.y; 
            });
            
            document.addEventListener('mouseup', () => {
                // Не нужно проверять здесь, так как isDragging не будет true, если mousedown был на плеере
                if (!isDragging) return;
                isDragging = false;
                targetScale = 1.0; 
                currentRotationSpeed = sphereLinesGroup.rotation.y - previousDragRotationY;
                currentRotationSpeed = Math.max(-0.05, Math.min(0.05, currentRotationSpeed)); 
                if (mouseX > 0.1) { rotationDirection = 1; } 
                else if (mouseX < -0.1) { rotationDirection = -1; }
            });
            
            document.addEventListener('touchstart', (event) => {
                 // --- Проверка: игнорируем касания внутри плеера --- 
                if (musicPlayerElement && musicPlayerElement.contains(event.target)) {
                    return; 
                }
                // ----------------------------------------------
                isDragging = true;
                startX = event.touches[0].clientX;
                startRotationY = sphereLinesGroup.rotation.y; 
                updateMouseX(event.touches[0].clientX);
                targetScale = scaleFactorOnInteract; 
                currentRotationSpeed = 0; 
                previousDragRotationY = sphereLinesGroup.rotation.y; 
            }, { passive: true }); 
            
            document.addEventListener('touchend', () => {
                 // Не нужно проверять здесь
                if (!isDragging) return;
                isDragging = false;
                targetScale = 1.0; 
                currentRotationSpeed = sphereLinesGroup.rotation.y - previousDragRotationY;
                currentRotationSpeed = Math.max(-0.05, Math.min(0.05, currentRotationSpeed)); 
                if (mouseX > 0.1) { rotationDirection = 1; } 
                else if (mouseX < -0.1) { rotationDirection = -1; }
            });

            // --- Окно ресайз --- 
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                // Обновляем размер composer и bloomPass
                composer.setSize(window.innerWidth, window.innerHeight);
                bloomPass.resolution.set(window.innerWidth, window.innerHeight);
                // --- Обновляем разрешение для LineMaterial --- 
                lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
                // ------------------------------------------
            });

            // --- Цикл анимации --- 
            function animate() {
                requestAnimationFrame(animate);

                // Анимация для ЕДИНСТВЕННОГО объекта (сферы)
                
                // Масштабирование
                currentScale += (targetScale - currentScale) * scaleInterpolationFactor;
                sphereLinesGroup.scale.set(currentScale, currentScale, currentScale);

                // Вращение
                if (isDragging) {
                    // Во время перетаскивания вращение управляется в mousemove/touchmove
                    // currentRotationSpeed остается 0
                } else {
                    // Плавно смешиваем текущую скорость (которая может быть инерционной)
                    // с целевой постоянной скоростью
                    const targetConstantSpeed = constantSpeed * rotationDirection;
                    currentRotationSpeed += (targetConstantSpeed - currentRotationSpeed) * inertiaFactor;
                    
                    // Применяем вращение с текущей скоростью
                    sphereLinesGroup.rotation.y += currentRotationSpeed;
                }
                
                // Сброс другого вращения
                sphereLinesGroup.rotation.x = 0;
                sphereLinesGroup.rotation.z = 0;
                
                // Используем composer для рендеринга с эффектами
                // renderer.render(scene, camera); // Заменяем эту строку
                composer.render(); 
            }

            animate();

            // ====================================================
            // ========== КОД МУЗЫКАЛЬНОГО ПЛЕЕРА ============
            // ====================================================

            const audioPlayer = new Audio();
            let playlistData = []; // Массив объектов { name: string, url: string }
            let currentTrackIndex = -1;
            let isAudioPlaying = false;
            let isSeekingProgress = false; // Флаг для отложенной перемотки прогресса
            let seekTargetTime = 0;      // Целевое время для отложенной перемотки
            let isSeekingVolume = false; // Флаг для перемотки громкости
            const maxVolumeFactor = 0.25; 
            const playerState = {
                isShuffle: false,
                isLoopingTrack: false
            };

            // --- !!! ВАШ СПИСОК ТРЕКОВ (ПРАВИЛЬНАЯ СТРУКТУРА) !!! ---
            // Замените этот список своими треками.
            // Используйте ОТНОСИТЕЛЬНЫЕ пути (если файлы в папке 'audio' рядом с index.html)
            // или ПОЛНЫЕ URL (если файлы в интернете).
            // ЛОКАЛЬНЫЕ ПУТИ (D:\...) РАБОТАТЬ НЕ БУДУТ!
            const predefinedTracks = [
                // --- Ваши треки из папки audio/ ---
                { name: "A$AP Rocky - LVL", url: "audio/A$AP Rocky - LVL.mp3" }, 
                { name: "eyes don't lie - insomnia", url: "audio/eyes don't lie - insomnia.mp3" },
                { name: "Lil B - Im a Leader", url: "audio/Lil B - Im a Leader.mp3" },
                { name: "Serial Experiments Lain - opening", url: "audio/Serial Experiments Lain - opening.mp3" },
                { name: "swerd, jdmfessh - august 11", url: "audio/swerd, jdmfessh - august 11.mp3" },
                { name: "w1tu - Too Good for Me", url: "audio/w1tu - Too Good for Me.mp3" },
                // -------------------------------------
            ];
            // -------------------------------------

            // --- Элементы UI плеера ---
            const playerElement = document.getElementById('music-player');
            const trackInfoElement = document.getElementById('track-info');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const timeDisplayElement = document.getElementById('time-display');
            const prevButton = document.getElementById('prev-button');
            const playPauseButton = document.getElementById('play-pause-button');
            const nextButton = document.getElementById('next-button');
            const volumeContainer = document.getElementById('volume-container');
            const volumeBar = document.getElementById('volume-bar');
            const addTrackButton = document.getElementById('add-track-button');
            const addTrackInput = document.getElementById('add-track-input');
            const playlistElement = document.getElementById('playlist');
            const shuffleButton = document.getElementById('shuffle-button');
            const loopButton = document.getElementById('loop-button');
            const playlistContainer = document.getElementById('playlist-container'); // Контейнер плейлиста
            const playlistToggleButton = document.getElementById('playlist-toggle-button'); // Кнопка-стрелка

            // --- Функции localStorage (больше не используются для загрузки) --- 
            function savePlaylistToStorage() {
                 // Если сохранять пользовательские треки не нужно, эту функцию можно удалить
                 // или оставить пустой / с console.log
                 console.log("Saving custom tracks (if any) is currently disabled.") 
            }

            // --- ФУНКЦИЯ ЗАГРУЗКИ ПРЕДОПРЕДЕЛЕННЫХ ТРЕКОВ --- 
            function loadInitialPlaylist() {
                console.log("Loading predefined tracks...");
                playlistData = predefinedTracks.map(track => ({ 
                    name: track.name, 
                    url: track.url, 
                    file: null 
                }));
                renderPlaylist(); 
                if (playlistData.length > 0) {
                    loadTrack(0); 
                } else {
                    disableControls();
                }
                console.log("Predefined tracks loaded.");
            }
            // --------------------------------------

            // --- Функции UI --- 
            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
            }

            function updateProgress() {
                if (isSeekingProgress) return; // Не обновляем во время перемотки
                if (!audioPlayer.duration) {
                    progressBar.style.width = '0%';
                    timeDisplayElement.textContent = '0:00 / 0:00';
                    return; 
                }
                const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progressBar.style.width = `${progress}%`;
                timeDisplayElement.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
            }

            function updateTrackInfo() {
                if (currentTrackIndex !== -1 && playlistData[currentTrackIndex]) {
                    trackInfoElement.textContent = playlistData[currentTrackIndex].name;
                    trackInfoElement.title = playlistData[currentTrackIndex].name; // Tooltip для длинных имен
                } else {
                    trackInfoElement.textContent = 'No track loaded';
                    trackInfoElement.title = '';
                }
                // Обновляем подсветку в плейлисте
                renderPlaylist();
            }
            
            function renderPlaylist() {
                playlistElement.innerHTML = ''; // Очищаем список
                playlistData.forEach((track, index) => {
                    const li = document.createElement('li');
                    li.textContent = track.name;
                    li.dataset.index = index; // Сохраняем индекс для клика
                    if (index === currentTrackIndex) {
                        li.classList.add('playing');
                    }
                    playlistElement.appendChild(li);
                });
            }

            function enableControls() {
                 playPauseButton.disabled = false;
                 prevButton.disabled = playlistData.length <= 1; // Блокируем если 1 трек
                 nextButton.disabled = playlistData.length <= 1; // Блокируем если 1 трек
            }

            function disableControls() {
                playPauseButton.disabled = true;
                prevButton.disabled = true;
                nextButton.disabled = true;
            }

            // --- Функции управления воспроизведением ---
            function loadTrack(index) {
                if (index < 0 || index >= playlistData.length) {
                    console.error("Invalid track index");
                    currentTrackIndex = -1;
                    audioPlayer.src = '';
                    updateTrackInfo();
                    updateProgress();
                    disableControls();
                    return;
                }

                const track = playlistData[index];
                currentTrackIndex = index;

                // Проверяем, есть ли уже URL (от File API)
                if (track.url) {
                    audioPlayer.src = track.url;
                    updateTrackInfo();
                    enableControls();
                } else if (track.file) {
                    // Создаем URL из файла, если его нет
                    track.url = URL.createObjectURL(track.file);
                    audioPlayer.src = track.url;
                    updateTrackInfo();
                    enableControls();
                } else {
                     // Если нет ни URL ни файла (после загрузки из localStorage), 
                     // трек нельзя воспроизвести пока пользователь не выберет файл снова
                     console.warn(`Track "${track.name}" needs to be selected again.`);
                     trackInfoElement.textContent = `Select file for: ${track.name}`;
                     audioPlayer.src = '';
                     disableControls(); // Блокируем управление для этого трека
                     updateProgress();
                     renderPlaylist(); // Обновить подсветку
                     return; // Не пытаемся играть
                }
            }

            function playAudio() {
                if (currentTrackIndex === -1 && playlistData.length > 0) {
                    loadTrack(0); // Загружаем первый трек, если ничего не выбрано
                }
                if(audioPlayer.src){ // Убедимся, что есть источник
                    audioPlayer.play().then(() => {
                        isAudioPlaying = true;
                        playPauseButton.textContent = 'Pause';
                    }).catch(error => {
                        console.error("Error playing audio:", error);
                        // Возможно, нужно взаимодействие пользователя
                        trackInfoElement.textContent = "Playback error. Try again.";
                    });
                } else if (playlistData.length > 0) {
                    // Попытка загрузить текущий трек, если src пуст (после загрузки из localStorage)
                    loadTrack(currentTrackIndex);
                }
            }

            function pauseAudio() {
                audioPlayer.pause();
                isAudioPlaying = false;
                playPauseButton.textContent = 'Play';
            }

            // --- МОДИФИЦИРОВАННАЯ ФУНКЦИЯ PLAY NEXT --- 
            function playNext() {
                if (playlistData.length === 0) return;
                let nextIndex;
                // Используем playerState.isShuffle
                if (playerState.isShuffle) { 
                    if (playlistData.length === 1) {
                        nextIndex = 0; 
                    } else {
                        do {
                            nextIndex = Math.floor(Math.random() * playlistData.length);
                        } while (nextIndex === currentTrackIndex);
                    }
                } else {
                    nextIndex = (currentTrackIndex + 1) % playlistData.length;
                }
                loadTrack(nextIndex);
                playAudio();
            }
            // ---------------------------------------------

            // --- ВОССТАНАВЛИВАЕМ УДАЛЕННЫЕ ФУНКЦИИ ---
            function playPrev() {
                if (playlistData.length === 0) return;
                let prevIndex = (currentTrackIndex - 1 + playlistData.length) % playlistData.length;
                loadTrack(prevIndex);
                playAudio();
            }

            function setVolume(level) {
                const actualVolume = Math.max(0, Math.min(1, level)) * maxVolumeFactor;
                audioPlayer.volume = actualVolume;
                volumeBar.style.width = `${Math.max(0, Math.min(1, level)) * 100}%`;
            }

            // --- Функция ВИЗУАЛЬНОЙ перемотки (для Deferred Seek) --- 
            function updateSeekVisual(event) {
                 if (!audioPlayer.duration) return;
                 const bounds = progressContainer.getBoundingClientRect();
                 let x = 0;
                 if (event.clientX !== undefined) { 
                     x = event.clientX - bounds.left;
                 } else if (event.touches && event.touches.length > 0) { 
                      x = event.touches[0].clientX - bounds.left;
                 } else { return; } 
                 const percentage = Math.max(0, Math.min(1, x / bounds.width));
                 seekTargetTime = percentage * audioPlayer.duration;
                 progressBar.style.width = `${percentage * 100}%`; // Обновляем только ползунок
            }
            // ----------------------------------------------------

            // --- Функция перемотки ГРОМКОСТИ (мгновенная) --- 
            function seekVolume(event) {
                 const bounds = volumeContainer.getBoundingClientRect();
                 let x = 0;
                 if (event.clientX !== undefined) {
                    x = event.clientX - bounds.left;
                 } else if (event.touches && event.touches.length > 0) {
                     x = event.touches[0].clientX - bounds.left;
                 } else { return; } 
                 const percentage = Math.max(0, Math.min(1, x / bounds.width));
                 setVolume(percentage); 
            }
            // ---------------------------------------------------

            // --- Обработчики событий плеера --- 
            // (Убедимся, что остался только ОДИН набор этих обработчиков)
            playPauseButton.addEventListener('click', () => {
                if (!audioPlayer.src && playlistData.length > 0) {
                    loadTrack(currentTrackIndex === -1 ? 0 : currentTrackIndex);
                    if(audioPlayer.src) playAudio();
                } else if (isAudioPlaying) {
                    pauseAudio();
                } else {
                    playAudio();
                }
            });
            nextButton.addEventListener('click', playNext);
            prevButton.addEventListener('click', playPrev);

            audioPlayer.addEventListener('timeupdate', updateProgress);
            audioPlayer.addEventListener('ended', () => {
                if (playerState.isLoopingTrack) { 
                    audioPlayer.currentTime = 0;
                    playAudio();
                } else {
                    playNext();
                }
            }); 
            audioPlayer.addEventListener('loadedmetadata', updateProgress);
            audioPlayer.addEventListener('volumechange', () => { 
                 const displayLevel = maxVolumeFactor > 0 ? Math.min(1, audioPlayer.volume / maxVolumeFactor) : 0;
                 volumeBar.style.width = `${displayLevel * 100}%`;
            });

            // Обработчики кнопок Shuffle/Loop (БЕЗ ЛОГОВ, правильные переменные)
            if (shuffleButton) {
                shuffleButton.addEventListener('click', () => {
                    playerState.isShuffle = !playerState.isShuffle;
                    shuffleButton.classList.toggle('active', playerState.isShuffle);
                });
            } else { console.error("Shuffle button not found!"); }
            if (loopButton) {
                loopButton.addEventListener('click', () => {
                    playerState.isLoopingTrack = !playerState.isLoopingTrack;
                    loopButton.classList.toggle('active', playerState.isLoopingTrack);
                });
            } else { console.error("Loop button not found!"); }

            // --- Обработчики добавления треков, плейлиста, toggle --- 
            addTrackButton.addEventListener('click', () => { addTrackInput.click(); });
            addTrackInput.addEventListener('change', (event) => {
                const files = event.target.files;
                if (!files) return;
                
                const newTracks = [];
                for (const file of files) {
                    // Проверяем, нет ли уже трека с таким именем
                    if (!playlistData.some(track => track.name === file.name)) {
                        newTracks.push({ 
                            name: file.name, 
                            url: URL.createObjectURL(file), // Сразу создаем URL
                            file: file // Сохраняем файл для возможного пересоздания URL
                        });
                    } else {
                        console.warn(`Track "${file.name}" already in playlist.`);
                    }
                }

                if (newTracks.length > 0) {
                    playlistData.push(...newTracks);
                    renderPlaylist();
                    savePlaylistToStorage(); // Сохраняем обновленный список имен
                    if (currentTrackIndex === -1) { // Если это первые треки
                        loadTrack(0);
                    } else {
                        enableControls(); // Обновляем доступность кнопок
                    }
                }
                addTrackInput.value = ''; // Сбрасываем input, чтобы можно было выбрать тот же файл снова
            });
            playlistElement.addEventListener('click', (event) => {
                if (event.target && event.target.tagName === 'LI') {
                    const index = parseInt(event.target.dataset.index, 10);
                    if (!isNaN(index)) {
                        if (index !== currentTrackIndex) {
                             // Клик на другой трек: загружаем и играем
                            loadTrack(index);
                            playAudio();
                        } else if (!isAudioPlaying) {
                            // Клик на текущий трек, который на паузе: просто играем
                            playAudio();
                        } 
                        // Если клик на текущий играющий трек - ничего не делаем
                    }
                }
            });
            playlistToggleButton.addEventListener('click', () => { playlistContainer.classList.toggle('playlist-visible'); });
            
            // === ОБРАБОТЧИКИ ПРОГРЕССА (Deferred Seek) ===
            // Убираем click listener
            // progressContainer.addEventListener('click', seek); 

            const startProgressListener = (initialEvent) => {
                if (!audioPlayer.duration) return;
                if (initialEvent.type === 'touchstart') initialEvent.preventDefault();
                isSeekingProgress = true;
                updateSeekVisual(initialEvent);

                const moveHandler = (moveEvent) => { 
                    if (moveEvent.type === 'touchmove') moveEvent.preventDefault();
                    updateSeekVisual(moveEvent);
                };
                const endHandler = () => {
                    if (isSeekingProgress) {
                        audioPlayer.currentTime = seekTargetTime;
                        isSeekingProgress = false;
                    }
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', endHandler);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', endHandler);
                };

                if (initialEvent.type === 'mousedown') {
                    document.addEventListener('mousemove', moveHandler);
                    document.addEventListener('mouseup', endHandler);
                } else if (initialEvent.type === 'touchstart') {
                     document.addEventListener('touchmove', moveHandler, { passive: false });
                     document.addEventListener('touchend', endHandler);
                }
            };
            progressContainer.addEventListener('mousedown', startProgressListener);
            progressContainer.addEventListener('touchstart', startProgressListener, { passive: false });
            // ==========================================================

            // === ОБРАБОТЧИКИ ГРОМКОСТИ (Мгновенные) ===
             const startVolumeListener = (initialEvent) => {
                 if (initialEvent.type === 'touchstart') initialEvent.preventDefault();
                 isSeekingVolume = true;
                 seekVolume(initialEvent);
                 
                 const moveHandler = (moveEvent) => { 
                     if (moveEvent.type === 'touchmove') moveEvent.preventDefault(); 
                     if (isSeekingVolume) { 
                          seekVolume(moveEvent);
                     }
                 };
                 const endHandler = () => {
                     isSeekingVolume = false;
                     document.removeEventListener('mousemove', moveHandler);
                     document.removeEventListener('mouseup', endHandler);
                     document.removeEventListener('touchmove', moveHandler);
                     document.removeEventListener('touchend', endHandler);
                 };
 
                 if (initialEvent.type === 'mousedown') {
                     document.addEventListener('mousemove', moveHandler);
                     document.addEventListener('mouseup', endHandler);
                 } else if (initialEvent.type === 'touchstart') {
                      document.addEventListener('touchmove', moveHandler, { passive: false });
                      document.addEventListener('touchend', endHandler);
                 }
             };
            volumeContainer.addEventListener('mousedown', startVolumeListener);
            volumeContainer.addEventListener('touchstart', startVolumeListener, { passive: false });
            // ============================================================

            // --- Инициализация плеера --- 
            setVolume(0.3); 
            loadInitialPlaylist(); 
            
            // ====================================================
            // ======= КОНЕЦ КОДА МУЗЫКАЛЬНОГО ПЛЕЕРА ========
            // ====================================================

        } catch (error) {
             const errorElement = document.getElementById('error-message');
             errorElement.textContent = 'Ошибка: ' + error.message;
             console.error('Ошибка:', error);
         }
    </script>
</body>
</html> 